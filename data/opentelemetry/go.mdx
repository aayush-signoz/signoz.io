---
title: Complete guide to implementing OpenTelemetry in Go applications
slug: go
date: 2024-12-10
tags: [opentelemetry-tutorials]
authors: [vishal, ankit_anand]
description: Learn how to use the language-specific implementation of OpenTelemetry in Go. OpenTelemetry Go libraries can be used to generate telemetry data from your Go applications which can then be sent to an observability tool for storage andâ€¦
image: /img/blog/2023/07/opentelemetry_golang_cover-min.jpg
keywords: [opentelemetry, opentelemetry golang, opentelemetry go, distributed tracing, observability, golang application monitoring, golang instrumentation, signoz]
---
**[OpenTelemetry](https://opentelemetry.io/)** is an open-source observability framework that generates and collects telemetry data (logs, metrics, and traces) from applications and services built in **[different languages or technology stacks](https://opentelemetry.io/docs/languages/)**. OpenTelemetry gives a simple and consistent way to instrument application code and capture the signals needed to understand whatâ€™s really happening in a system, abstracting the effort of juggling different vendor-specific agents or custom libraries for every environment. Once data is collected, it can be exported to any compatible backend or observability platform for storage, visualisation, and analysis.

<figure data-zoomable align='center'>
<img src="/img/blog/2024/12/opentelemetry-golang-cover.webp" alt="Monitor your Go applications with SigNoz"/>
</figure>

Modern Golang applications run inside distributed systems with multiple microservices, containers, serverless functions, background workers, and event-driven pipelines. As this complexity grows, even simple troubleshooting like below becomes challenging:
- Why is this request slow?
- Where is the error actually coming from?
- Which service caused the latency spike?
- What happened right before the failure?

Traditional logs alone canâ€™t answer these questions. They give you pieces, not the whole picture. To truly understand what your system is doing, you need traces, metrics, and logs working together in unison.

Thatâ€™s where OpenTelemetry becomes the difference between guessing and knowing.

In this tutorial, we will use OpenTelemetry Golang libraries to instrument a Golang application and then visualize it using an open-source observability tool -Â [**SigNoz**](https://signoz.io/).

Steps to get started with OpenTelemetry for Go applications:

- [**Instrumenting a Go application with OpenTelemetry**](https://signoz.io/opentelemetry/go/#instrumenting-your-golang-application-with-opentelemetry)
- [**Generating telemetry data from your application**](https://signoz.io/opentelemetry/go/#generating-telemetry-data-from-your-application)
- [**Connecting a Observability Backend - SigNoz**](https://signoz.io/opentelemetry/go/#creating-a-signoz-cloud-account)
- [**Monitoring your Go application with SigNoz dashboards**](https://signoz.io/opentelemetry/go/#monitor-your-go-application-with-signoz-dashboards)
- [**Adding custom attributes and custom events to spans**](https://signoz.io/opentelemetry/go/#adding-custom-attributes-and-custom-events-to-spans)

## Prerequisites
1. **[Go Installed (v1.20 or later)](https://go.dev/doc/install)**: Required to build and run the application.
2. **[Git Installed](https://git-scm.com/install/)**: Needed to clone the sample repository
3. **[SQLite Installed](https://www.sqlite.org/download.html)**: The sample app uses SQLite as its database through Gorm.

## Instrumenting your Golang application with OpenTelemetry

Follow the below steps to instrument your Golang application with OpenTelemetry:

**Step 1: Get a sample Golang app from GitHub**

In this tutorial we have created aÂ **[sample Golang app repo](https://github.com/SigNoz/sample-golang-app)** whichÂ contains the boilerplate code that builds a sample golang app using Gin and Gorm.

If you want to follow along with the tutorial, clone theÂ **`without-instrumentation`**Â branch:

```bash
git clone -b without-instrumentation https://github.com/SigNoz/sample-golang-app.git
cd sample-golang-app
```

**Step 2: Install dependencies**

Dependencies related to **[OpenTelemetry exporter](https://signoz.io/guides/opentelemetry-collector-vs-exporter/)** and SDK have to be installed first. Note that we are assuming you are usingÂ **`gin`**Â request router. If you are using other request routers, check out theÂ [**corresponding package**](https://signoz.io/docs/instrumentation/opentelemetry-golang/#request-routers).

Run the below commands after navigating to the application source folder:

```go
  go get go.opentelemetry.io/otel \
  go.opentelemetry.io/otel/trace \
  go.opentelemetry.io/otel/sdk \
  go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin \
  go.opentelemetry.io/otel/exporters/otlp/otlptrace \
  go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc
```

- **`otel`**: Core OpenTelemetry APIs for Go
- **`otel/trace`**: Tracing interfaces and utilities
- **`otel/sdk`**: SDK implementation for telemetry
- **`otelgin`**: Auto-instrumentation for Gin framework
- **`otlptrace`**: OTLP exporter for traces
- **`otlptracegrpc`**: Send traces over gRPC protocol

**Step 3: Declare environment variables for configuring OpenTelemetry**

Declare the following global variables in theÂ **`main.go`**Â file after the import block. This will be used to configure OpenTelemetry:

```go
var (
	serviceName  = os.Getenv("SERVICE_NAME")
	collectorURL = os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	insecure     = os.Getenv("INSECURE_MODE")
)
```

The environment variables used here are explained in detail in Step 7 to help you configure them correctly.

**Step 4: Instrument your Go application with OpenTelemetry**

To configure your application to send data, we will need a function to initialize OpenTelemetry. Add the following snippet of code in yourÂ **`main.go`**Â file:

```go
import (
	"context"
	"log"
	"os"
	"strings"
	
	.....
	
	"google.golang.org/grpc/credentials"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"

	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
)
```

- **`attribute`**: Used to attach useful descriptive data to spans, like `user_id`, `region`, `request_type` making traces meaningful and searchable.
- **`resource`**: Stores information about what is producing telemetry such as `service name`, `environment (prod/staging)`, `version`, `container ID`, etc.
- **`sdktrace`**: Used to create, manage and sample spans, and sends them to tracing backend.

Add this after the variable declaration (var) block:

```go
func initTracer() func(context.Context) error {

    var secureOption otlptracegrpc.Option

    // Decide whether to use secure TLS or insecure transfer based on environment variable
    if strings.ToLower(insecure) == "false" || insecure == "0" || strings.ToLower(insecure) == "f" {
        secureOption = otlptracegrpc.WithTLSCredentials(credentials.NewClientTLSFromCert(nil, ""))
    } else {
        secureOption = otlptracegrpc.WithInsecure()
    }

    // Create OTLP trace exporter to send spans to collector
    exporter, err := otlptrace.New(
        context.Background(),
        otlptracegrpc.NewClient(
            secureOption,
            otlptracegrpc.WithEndpoint(collectorURL), // OTLP receiver URL
        ),
    )

    if err != nil {
        log.Fatalf("Failed to create exporter: %v", err)
    }

    // Define resource metadata for this service (identifies the application)
    resources, err := resource.New(
        context.Background(),
        resource.WithAttributes(
            attribute.String("service.name", serviceName),   // logical service name
            attribute.String("library.language", "go"),      // programming language
        ),
    )
    if err != nil {
        log.Fatalf("Could not set resources: %v", err)
    }

    // Configure OpenTelemetry tracer provider
    otel.SetTracerProvider(
        sdktrace.NewTracerProvider(
            sdktrace.WithSampler(sdktrace.AlwaysSample()),  // capture every trace without sampling
            sdktrace.WithBatcher(exporter),                 // batch spans for efficient delivery
            sdktrace.WithResource(resources),               // attach resource metadata to each trace
        ),
    )

    // Return shutdown function to flush remaining traces on exit
    return exporter.Shutdown
}

```

Above function will wire up OpenTelemetry tracing for your Go service. It creates the OTLP exporter that pushes traces to your collector, assigns metadata so the backend knows which service the traces belong to, and configures the tracer provider to sample, batch, and manage spans efficiently. It also returns a shutdown function to ensure all pending traces are flushed when the app stops.

- **`otlptrace.New`**: creates the OTLP trace exporter
- **`resource.WithAttributes`**: defines service metadata (`service.name`, etc.)
- **`sdktrace.NewTracerProvider`**: main engine for tracing in the app
- **`sdktrace.AlwaysSample`**: records every span instead of sampling
- **`sdktrace.WithBatcher`**: batches trace exports for performance
- **`exporter.Shutdown`**: flushes data before shutdown

**Step 5: Initialize tracing inside `main.go`**

Now we activate tracing at the very start of the application lifecycle, modify the main function to initialise the tracer inÂ **`main.go`**:

```go
func main() {
	cleanup := initTracer()
	defer cleanup(context.Background())

	......
}
```

Calling `initTracer()` bootstraps telemetry, and `defer cleanup(context.Background())` ensures that when your service stops, all buffered spans are properly sent before shutdown. This helps ensure clean, complete trace data in your observability backend.

**Step 6: Add the OpenTelemetry Gin middleware**

Configure Gin to use the middleware by adding the following lines inÂ **`main.go`**.

```go
import (
	....
  "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
)

func main() {
	......
	r.Use(otelgin.Middleware(serviceName))
	......
}
```

By importing `otelgin` and adding `r.Use(otelgin.Middleware(serviceName))`, every incoming HTTP request automatically gets traced, including route, latency, status, and context propagation without needing manual instrumentation in each handler. It basically plugs in middleware and your Gin service becomes observable.

This is what your **`main.go`** file should look like after instrumentation:

```go
package main

import (
	"context"
	"log"
	"os"
	"strings"

	"github.com/SigNoz/sample-golang-app/controllers"
	"github.com/SigNoz/sample-golang-app/models"

	"github.com/gin-gonic/gin"
	
	// For secure/insecure OTLP communication over gRPC
	"google.golang.org/grpc/credentials"

	// Core OpenTelemetry libraries
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"

	// Define service identity & metadata
	"go.opentelemetry.io/otel/sdk/resource"

	// Tracing provider + span management
	sdktrace "go.opentelemetry.io/otel/sdk/trace"

	// Auto-instrumentation for Gin HTTP requests
	"go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
)

var (
	// App/service name sent to SigNoz
	serviceName = os.Getenv("SERVICE_NAME")

	// SigNoz / OTLP endpoint
	collectorUR = os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")

	// Whether to use TLS or not
	insecure = os.Getenv("INSECURE_MODE")
)

func initTracer() func(context.Context) error {

	var secureOption otlptracegrpc.Option

	// Choose secure vs insecure OTLP connection based on config
	if strings.ToLower(insecure) == "false" || insecure == "0" || strings.ToLower(insecure) == "f" {
		secureOption = otlptracegrpc.WithTLSCredentials(credentials.NewClientTLSFromCert(nil, ""))
	} else {
		secureOption = otlptracegrpc.WithInsecure()
	}

	// Initialize OTLP trace exporter
	exporter, err := otlptrace.New(
		context.Background(),
		otlptracegrpc.NewClient(
			secureOption,
			otlptracegrpc.WithEndpoint(collectorURL),
		),
	)
	if err != nil {
		log.Fatalf("Failed to create exporter: %v", err)
	}

	// Attach metadata such as service.name & language
	resources, err := resource.New(
		context.Background(),
		resource.WithAttributes(
			attribute.String("service.name", serviceName),
			attribute.String("library.language", "go"),
		),
	)
	if err != nil {
		log.Fatalf("Could not set resources: %v", err)
	}

	// Configure tracer provider: always sample + batch export
	otel.SetTracerProvider(
		sdktrace.NewTracerProvider(
			sdktrace.WithSampler(sdktrace.AlwaysSample()),
			sdktrace.WithBatcher(exporter),
			sdktrace.WithResource(resources),
		),
	)

	// Return cleanup function
	return exporter.Shutdown
}

func main() {
	// Start tracer / cleanup when program exits
	cleanup := initTracer()
	defer cleanup(context.Background())
	
	r := gin.Default()

	// Automatically trace all HTTP requests
	r.Use(otelgin.Middleware(serviceName))

	// Connect DB
	models.ConnectDatabase()

	// Application routes
	r.GET("/books", controllers.FindBooks)
	r.GET("/books/:id", controllers.FindBook)
	r.POST("/books", controllers.CreateBook)
	r.PATCH("/books/:id", controllers.UpdateBook)
	r.DELETE("/books/:id", controllers.DeleteBook)

	// Start web server
	r.Run(":8090")
}
```

**Step 7: Run your Go Gin application**

Now that you have completely set up the application, it's time to run some CRUD operations. Run the following command to set the environment variables and start the application:

```bash
SERVICE_NAME=goApp INSECURE_MODE=false go run main.go
```

- **`SERVICE_NAME`**: This variable defines the name of your application service, it helps in identifying telemetry data from this specific service. You can name it anything you prefer.
- **`INSECURE_MODE`**: When set to `false`, this ensures that the connection between your application and backend service is secure (using TLS). It's recommended to keep it as `false` for production environments.

And congratulations! You have successfully instrumented and started your sample Golang application.

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/go-app-running.webp" alt="Go App started successfully"/>
</figure>

## Generating telemetry data from your application

To ensure that telemetry data is generated, interact with your application by hitting the **`/books`** endpoint of the bookstore app. You can do this by navigating to [**http://localhost:8090/books**](http://localhost:8090/books) in your browser or using a tool like **`curl`** or Postman.

Refresh the endpoint multiple times to simulate load. Wait for 1â€“2 minutes, and the telemetry data will appear on your SigNoz dashboard, providing insights into your applicationâ€™s performance.

Alternatively, you can explore the application's functionality by performing CRUD operations. Below are examples to interact with the bookstore app:

1. **Retrieve All Books**

Send a `GET` request to fetch the list of books:

```bash
curl http://localhost:8090/books
```

Output:

```bash
{"data":[]}% 
```

Since there are no books yet, the response will be empty.

2. **Create a New Book**

Send a `POST` request to add a new book:

```bash
curl -X POST http://localhost:8090/books \
     -H "Content-Type: application/json" \
     -d '{"title":"Go Programming", "author":"John Doe"}'
```

Output:

```bash
{"data":[{"id":1,"title":"Go Programming","author":"John Doe"}]}%  
```

3. **Retrieve a Specific Book**

Send a `GET` request to fetch the details of a specific book by its ID:

```bash
curl http://localhost:8090/books/1
```

Output:

```bash
{"data":{"id":1,"title":"Go Programming","author":"John Doe"}}
```

4. **Update a Book**

Send a `PATCH` request to update the title of the book:

```bash
curl -X PATCH http://localhost:8090/books/1 \
     -H "Content-Type: application/json" \
     -d '{"title":"Updated Title"}'
```

Output:

```bash
{"data":{"id":1,"title":"Updated Title","author":"John Doe"}}% 
```

5. **Delete a Book**

Send a `DELETE` request to remove the book by its ID:

```bash
curl -X DELETE http://localhost:8090/books/1
```

Output:

```bash
{"data":true}% 
```

By performing these interactions, your application will generate telemetry data, which OpenTelemetry will process and forward to a observability backend for visualization and analysis. 

## Connecting a observability backend - SigNoz

SigNoz cloud is the easiest way to run SigNoz. You can sign upÂ [**here**](https://signoz.io/teams/)Â for a free account and get 30 days of unlimited access to all features.

![https://signoz.io/img/launch_week/try-signoz-cloud-blog-cta.png](https://signoz.io/img/launch_week/try-signoz-cloud-blog-cta.png)

After you sign up and verify your email, you will be provided with details of your SigNoz cloud instance. Once you set up your password and log in, you will be greeted with the following onboarding screen.

<figure data-zoomable align='center'>
<img src="/img/opentelemetry/2024/06/onboarding-screen.webp" alt="Onboarding screen in SigNoz"/>
<figcaption><i>Onboarding screen in SigNoz</i></figcaption>
</figure>

Since we will be following instructions from the tutorial, you can skip onboarding by clicking on the SigNoz logo.

You will see the below screen:

<figure data-zoomable align='center'>
<img src="/img/blog/2024/12/services-tab.webp" alt="Services tab in SigNoz"/>
<figcaption><i>Services tab in SigNoz</i></figcaption>
</figure>

For sending data to SigNoz cloud, you will be needing details like ingestion key and region. You can find them underÂ **`Ingestion Settings`**Â underÂ **`Settings`**.

<figure data-zoomable align='center'>
<img src="/img/blog/2024/12/ingestion-settings.webp" alt="ingestion settings"/>
<figcaption><i>Ingestion details for your SigNoz cloud account</i></figcaption>
</figure>

## Monitor your Go application with SigNoz dashboards

With the above steps, you have instrumented your Go application with [OpenTelemetry](https://signoz.io/blog/what-is-opentelemetry/). OpenTelemetry sends the collected data to SigNoz which can be used to store it and visualize it. Letâ€™s see how SigNoz can help you monitor your Go application. You need to set some environment variables to send data to SigNoz backend and run your application.

Restart the application with following command to set the environment variables:

```bash
SERVICE_NAME=goApp INSECURE_MODE=false OTEL_EXPORTER_OTLP_HEADERS=signoz-ingestion-key=<SIGNOZ-INGESTION-KEY> OTEL_EXPORTER_OTLP_ENDPOINT=ingest.{region}.signoz.cloud:443 go run main.go
```

- **`OTEL_EXPORTER_OTLP_HEADERS`**: This header contains the SigNoz ingestion key for authentication. Replace `<SIGNOZ_INGESTION_KEY>` with your actual [ingestion token](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- **`OTEL_EXPORTER_OTLP_ENDPOINT`**: This defines the endpoint where your application will send telemetry data, `ingest.{region}.signoz.cloud:443`. Depending on the choice of your region for SigNoz cloud, the ingest endpoint will vary according to this table.

	| Region | Endpoint |
	| --- | --- |
	| US | ingest.us.signoz.cloud:443 |
	| IN | ingest.in.signoz.cloud:443 |
	| EU | ingest.eu.signoz.cloud:443 |

To see meaningful results in SigNoz, we need the application to actually process requests, otherwise thereâ€™s nothing for OpenTelemetry to capture. Since we are using a local sample app without real users, we need to generate synthetic traffic to simulate real-world API usage. Once the application is running, simply execute the provided **`generate_traffic.sh`** script to start producing telemetry data that you can immediately observe inside SigNoz using the below command:

```bash
chmod +x generate_traffic.sh
./generate_traffic.sh
```

The script performs a repeated sequence of CRUD operations on the **`/books`** API, which produces spans and events that show up in SigNoz dashboards. This allows us to visualize service latency, error behavior, and trace flows through the system as if it were receiving real user requests.

Navigate to our SigNoz cloud account. On the service page, you should see your **`goApp`** service.

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/services-tab-go.webp" alt="Go app being monitored under services tab"/>
<figcaption><i>Your Go Gin application being monitored on the SigNoz dashboard</i></figcaption>
</figure>

You can monitor application metrics like application latency, requests per second, error percentage, etc. with theÂ **`Metrics`**Â tab of SigNoz. 

Click on the **`goApp`** service and you should be redirected to the metrics page.

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/metrics-page-go.webp" alt="Metrics from Go app"/>
<figcaption><i>Monitor your Go Gin application metrics like application latency, requests per second, error percentage, etc.</i></figcaption>
</figure>

OpenTelemetry captures tracing data from your Gin application as well. Tracing data can help you visualize how user requests perform across services in a multi-service application.

In theÂ **`Traces`**Â tab of SigNoz, you can analyze the tracing data using filters based on tags, status codes, service names, operations, etc.

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/traces-tab-go.webp" alt="Traces tab"/>
<figcaption><i>Use powerful filters to analyze your tracing data from the Gin application</i></figcaption>
</figure>

You can also visualize your tracing data with the help ofÂ [**flamegraphs and Gantt charts**](https://signoz.io/blog/flamegraphs/).

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/flamegraphs-go.webp" alt="Flamegraphs and Gantt charts visualization"/>
<figcaption><i>Flamegraphs and Gantt charts on SigNoz dashboard</i></figcaption>
</figure>

## Adding custom attributes and custom events to spans

In OpenTelemetry, [**spans**](https://signoz.io/blog/distributed-tracing-span/) represent a single unit of work in a distributed trace. You can enrich these spans with **custom attributes** and **custom events** to capture additional context and insights about the operations your application is performing. This is useful for observability and debugging, as it allows you to track specific details in the trace, providing more valuable insights into your system's behavior.

Hereâ€™s how you can add **custom attributes** and **custom events** to spans in your Go application:

**Step 1: Import trace and attribute libraries**

To add attributes and events to spans, youâ€™ll need to import the necessary OpenTelemetry libraries. In your **`controllers/books.go`** file, include the following imports:

```go
import (
	...
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)
```

- **`go.opentelemetry.io/otel/attribute`**: This package is used to define attributes for spans.
- **`go.opentelemetry.io/otel/trace`**: This package provides the functionality for managing spans, including adding events and attributes.

**Step 2: Fetch current span from context**

In OpenTelemetry, each span is associated with a request context. To add attributes and events to a span, you first need to fetch the span from the context associated with the incoming request. You can do this by using:

```go
span := trace.SpanFromContext(c.Request.Context())
```

Here, **`c.Request.Context()`** gets the context of the HTTP request, which carries the current span.

**Step 3: Set custom attributes on the Span**

Attributes are key-value pairs that provide additional metadata to a span. You can add custom attributes to the current span using **`span.SetAttributes()`**:

```go
span.SetAttributes(attribute.String("controller", "books"))
```

This adds an attribute **`"controller" = "books"`** to the span, helping you identify which part of the application (in this case, the "books" controller) is responsible for the span.

**Step 4: Add custom events to the span**

Events provide a way to track specific actions or errors within the spanâ€™s context. You can add events to a span using **`span.AddEvent()`**:

```go
span.AddEvent("This is a sample event", trace.WithAttributes(attribute.Int("pid", 4328), attribute.String("sampleAttribute", "Test")))
```

In this example, an event named **`"This is a sample event"`** is added to the span, with custom attributes **`"pid" = 4328`** and **`"sampleAttribute" = "Test"`**. These events can help you track specific actions or errors within the span's context.

**Implementation in your `goGin` Application**

In your project folder directory, open the **`controllers/books.go`** file and update it with the following configuration:

```go
package controllers

import (
	"net/http"

	"github.com/SigNoz/sample-golang-app/models"
	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
)

type CreateBookInput struct {
	Title  string `json:"title" binding:"required"`
	Author string `json:"author" binding:"required"`
}

type UpdateBookInput struct {
	Title  string `json:"title"`
	Author string `json:"author"`
}

// GET /books
// Find all books
func FindBooks(c *gin.Context) {
	span := trace.SpanFromContext(c.Request.Context())
	span.SetAttributes(attribute.String("controller", "books"))
	span.AddEvent("Fetching books")

	var books []models.Book
	models.DB.Find(&books)

	c.JSON(http.StatusOK, gin.H{"data": books})
}

// GET /books/:id
// Find a book
func FindBook(c *gin.Context) {
	span := trace.SpanFromContext(c.Request.Context())
	span.SetAttributes(attribute.String("controller", "books"))
	span.AddEvent("Fetching single book")

	// Get model if exist
	var book models.Book
	if err := models.DB.Where("id = ?", c.Param("id")).First(&book).Error; err != nil {
		span.AddEvent("Book not found", trace.WithAttributes(
			attribute.String("book_id", c.Param("id")),
		))
		c.JSON(http.StatusBadRequest, gin.H{"error": "Record not found!"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"data": book})
}

// POST /books
// Create new book
func CreateBook(c *gin.Context) {
	span := trace.SpanFromContext(c.Request.Context())
	span.SetAttributes(attribute.String("controller", "books"))
	span.AddEvent("Creating book")

	// Validate input
	var input CreateBookInput
	if err := c.ShouldBindJSON(&input); err != nil {
		span.AddEvent("Book creation failed", trace.WithAttributes(
			attribute.String("error", err.Error()),
		))
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Create book
	book := models.Book{Title: input.Title, Author: input.Author}
	models.DB.Create(&book)

	span.AddEvent("Book created", trace.WithAttributes(
		attribute.Int("book_id", int(book.ID)),
	))

	c.JSON(http.StatusOK, gin.H{"data": book})
}

// PATCH /books/:id
// Update a book
func UpdateBook(c *gin.Context) {
	span := trace.SpanFromContext(c.Request.Context())
	span.SetAttributes(attribute.String("controller", "books"))
	span.AddEvent("Updating book")

	// Get model if exist
	var book models.Book
	if err := models.DB.Where("id = ?", c.Param("id")).First(&book).Error; err != nil {
		span.AddEvent("Book not found", trace.WithAttributes(
			attribute.String("book_id", c.Param("id")),
		))
		c.JSON(http.StatusBadRequest, gin.H{"error": "Record not found!"})
		return
	}

	// Validate input
	var input UpdateBookInput
	if err := c.ShouldBindJSON(&input); err != nil {
		span.AddEvent("Book update failed", trace.WithAttributes(
			attribute.String("error", err.Error()),
		))
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	models.DB.Model(&book).Updates(input)

	span.AddEvent("Book updated", trace.WithAttributes(
		attribute.Int("book_id", int(book.ID)),
	))

	c.JSON(http.StatusOK, gin.H{"data": book})
}

// DELETE /books/:id
// Delete a book
func DeleteBook(c *gin.Context) {
	span := trace.SpanFromContext(c.Request.Context())
	span.SetAttributes(attribute.String("controller", "books"))
	span.AddEvent("Deleting book")

	// Get model if exist
	var book models.Book
	if err := models.DB.Where("id = ?", c.Param("id")).First(&book).Error; err != nil {
		span.AddEvent("Book not found", trace.WithAttributes(  // Added error event
			attribute.String("book_id", c.Param("id")),
		))
		c.JSON(http.StatusBadRequest, gin.H{"error": "Record not found!"})
		return
	}

	models.DB.Delete(&book)

	span.AddEvent("Book deleted", trace.WithAttributes(  // Added success event
		attribute.Int("book_id", int(book.ID)),
	))

	c.JSON(http.StatusOK, gin.H{"data": true})
}
```

Once you've updated your application, restart it and generate new telemetry data. Then, navigate to your SigNoz cloud account and select one of the traces. You should be able to see the custom attributes and events that you've added. These will provide more insights into the activities taking place within your application, improving the observability and debugging process.

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/custom-attributes.webp" alt="Custom attributes"/>
<figcaption><i>Custom attributes can seen underÂ **`Attributes`**Â section on SigNoz trace detail page</i></figcaption>
</figure>

<figure data-zoomable align='center'>
<img src="/img/blog/2025/11/events.webp" alt="Events"/>
<figcaption><i>Events can be seen underÂ **`Events`**Â section on SigNoz trace detail page</i></figcaption>
</figure>

## Conclusion

Using OpenTelemetry libraries, you can instrument your Go applications for setting up observability. You can then use an open-source APM tool like SigNoz to ensure the smooth performance of your Go applications.

OpenTelemetry is the future for setting up observability for cloud-native apps. It is backed by a huge community and covers a wide variety of technology and frameworks. Using OpenTelemetry, engineering teams can instrument polyglot and distributed applications with peace of mind.

SigNoz is an open-source observability tool that comes with a SaaS-like experience. You can try out SigNoz by visiting its GitHub repo ðŸ‘‡

![https://signoz.io/img/blog/common/signoz_github.webp](https://signoz.io/img/blog/common/signoz_github.webp)

If you want to read more about how to integrate Metrics and Logs using Golang ðŸ‘‡

- [**How to set up Golang application performance monitoring with open source monitoring tool - SigNoz**](https://signoz.io/blog/monitoring-your-go-application-with-signoz/)
- [**Complete Guide to Logging in Go - Golang Log**](https://signoz.io/guides/golang-log/)

---

**Further Reading**

[**SigNoz - an open-source alternative to DataDog**](https://signoz.io/blog/open-source-datadog-alternative/)
